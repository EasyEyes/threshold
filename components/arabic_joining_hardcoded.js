// Generated from Unicode ArabicShaping.txt â†’ hard-coded joining tables.
// This file was auto-produced to avoid runtime parsing.

const JT_U = new Set([
  0x0600, 0x0601, 0x0602, 0x0603, 0x0604, 0x0605, 0x0608, 0x060b, 0x0621,
  0x0674, 0x06dd, 0x0861, 0x0866, 0x0887, 0x0888, 0x0890, 0x0891, 0x08ad,
  0x08e2, 0x1806, 0x180e, 0x1880, 0x1881, 0x1882, 0x1883, 0x1884, 0x200c,
  0x202f, 0x2066, 0x2067, 0x2068, 0x2069, 0xa873, 0x10ac6, 0x10ac8, 0x10acb,
  0x10acc, 0x10ae2, 0x10ae3, 0x10baf, 0x10f45, 0x10fb1, 0x10fb7, 0x10fc0,
  0x10fc5, 0x10fc6, 0x10fc7, 0x10fc8, 0x110bd, 0x110cd,
]);

const JT_R = new Set([
  0x0622, 0x0623, 0x0624, 0x0625, 0x0627, 0x0629, 0x062f, 0x0630, 0x0631,
  0x0632, 0x0648, 0x0671, 0x0672, 0x0673, 0x0675, 0x0676, 0x0677, 0x0688,
  0x0689, 0x068a, 0x068b, 0x068c, 0x068d, 0x068e, 0x068f, 0x0690, 0x0691,
  0x0692, 0x0693, 0x0694, 0x0695, 0x0696, 0x0697, 0x0698, 0x0699, 0x06c0,
  0x06c3, 0x06c4, 0x06c5, 0x06c6, 0x06c7, 0x06c8, 0x06c9, 0x06ca, 0x06cb,
  0x06cd, 0x06cf, 0x06d2, 0x06d3, 0x06d5, 0x06ee, 0x06ef, 0x0710, 0x0715,
  0x0716, 0x0717, 0x0718, 0x0719, 0x071e, 0x0728, 0x072a, 0x072c, 0x072f,
  0x074d, 0x0759, 0x075a, 0x075b, 0x076b, 0x076c, 0x0771, 0x0773, 0x0774,
  0x0778, 0x0779, 0x0840, 0x0846, 0x0847, 0x0849, 0x0854, 0x0856, 0x0857,
  0x0858, 0x0867, 0x0869, 0x086a, 0x0870, 0x0871, 0x0872, 0x0873, 0x0874,
  0x0875, 0x0876, 0x0877, 0x0878, 0x0879, 0x087a, 0x087b, 0x087c, 0x087d,
  0x087e, 0x087f, 0x0880, 0x0881, 0x0882, 0x088e, 0x08aa, 0x08ab, 0x08ac,
  0x08ae, 0x08b1, 0x08b2, 0x08b9, 0x10ac5, 0x10ac7, 0x10ac9, 0x10aca, 0x10ace,
  0x10acf, 0x10ad0, 0x10ad1, 0x10ad2, 0x10add, 0x10ae1, 0x10ae4, 0x10aef,
  0x10b81, 0x10b83, 0x10b84, 0x10b85, 0x10b89, 0x10b8c, 0x10b8e, 0x10b8f,
  0x10b91, 0x10ba9, 0x10baa, 0x10bab, 0x10bac, 0x10d22, 0x10ec2, 0x10f33,
  0x10f54, 0x10f74, 0x10f75, 0x10fb4, 0x10fb5, 0x10fb6, 0x10fb9, 0x10fba,
  0x10fbd, 0x10fc2, 0x10fc3, 0x10fc9,
]);

const JT_L = new Set([0xa872, 0x10acd, 0x10ad7, 0x10d00, 0x10fcb]);

const JT_D = new Set([
  0x0620, 0x0626, 0x0628, 0x062a, 0x062b, 0x062c, 0x062d, 0x062e, 0x0633,
  0x0634, 0x0635, 0x0636, 0x0637, 0x0638, 0x0639, 0x063a, 0x063b, 0x063c,
  0x063d, 0x063e, 0x063f, 0x0641, 0x0642, 0x0643, 0x0644, 0x0645, 0x0646,
  0x0647, 0x0649, 0x064a, 0x066e, 0x066f, 0x0678, 0x0679, 0x067a, 0x067b,
  0x067c, 0x067d, 0x067e, 0x067f, 0x0680, 0x0681, 0x0682, 0x0683, 0x0684,
  0x0685, 0x0686, 0x0687, 0x069a, 0x069b, 0x069c, 0x069d, 0x069e, 0x069f,
  0x06a0, 0x06a1, 0x06a2, 0x06a3, 0x06a4, 0x06a5, 0x06a6, 0x06a7, 0x06a8,
  0x06a9, 0x06aa, 0x06ab, 0x06ac, 0x06ad, 0x06ae, 0x06af, 0x06b0, 0x06b1,
  0x06b2, 0x06b3, 0x06b4, 0x06b5, 0x06b6, 0x06b7, 0x06b8, 0x06b9, 0x06ba,
  0x06bb, 0x06bc, 0x06bd, 0x06be, 0x06bf, 0x06c1, 0x06c2, 0x06cc, 0x06ce,
  0x06d0, 0x06d1, 0x06fa, 0x06fb, 0x06fc, 0x06ff, 0x0712, 0x0713, 0x0714,
  0x071a, 0x071b, 0x071c, 0x071d, 0x071f, 0x0720, 0x0721, 0x0722, 0x0723,
  0x0724, 0x0725, 0x0726, 0x0727, 0x0729, 0x072b, 0x072d, 0x072e, 0x074e,
  0x074f, 0x0750, 0x0751, 0x0752, 0x0753, 0x0754, 0x0755, 0x0756, 0x0757,
  0x0758, 0x075c, 0x075d, 0x075e, 0x075f, 0x0760, 0x0761, 0x0762, 0x0763,
  0x0764, 0x0765, 0x0766, 0x0767, 0x0768, 0x0769, 0x076a, 0x076d, 0x076e,
  0x076f, 0x0770, 0x0772, 0x0775, 0x0776, 0x0777, 0x077a, 0x077b, 0x077c,
  0x077d, 0x077e, 0x077f, 0x07ca, 0x07cb, 0x07cc, 0x07cd, 0x07ce, 0x07cf,
  0x07d0, 0x07d1, 0x07d2, 0x07d3, 0x07d4, 0x07d5, 0x07d6, 0x07d7, 0x07d8,
  0x07d9, 0x07da, 0x07db, 0x07dc, 0x07dd, 0x07de, 0x07df, 0x07e0, 0x07e1,
  0x07e2, 0x07e3, 0x07e4, 0x07e5, 0x07e6, 0x07e7, 0x07e8, 0x07e9, 0x07ea,
  0x0841, 0x0842, 0x0843, 0x0844, 0x0845, 0x0848, 0x084a, 0x084b, 0x084c,
  0x084d, 0x084e, 0x084f, 0x0850, 0x0851, 0x0852, 0x0853, 0x0855, 0x0860,
  0x0862, 0x0863, 0x0864, 0x0865, 0x0868, 0x0886, 0x0889, 0x088a, 0x088b,
  0x088c, 0x088d, 0x08a0, 0x08a1, 0x08a2, 0x08a3, 0x08a4, 0x08a5, 0x08a6,
  0x08a7, 0x08a8, 0x08a9, 0x08af, 0x08b0, 0x08b3, 0x08b4, 0x08b5, 0x08b6,
  0x08b7, 0x08b8, 0x08ba, 0x08bb, 0x08bc, 0x08bd, 0x08be, 0x08bf, 0x08c0,
  0x08c1, 0x08c2, 0x08c3, 0x08c4, 0x08c5, 0x08c6, 0x08c7, 0x08c8, 0x1807,
  0x1820, 0x1821, 0x1822, 0x1823, 0x1824, 0x1825, 0x1826, 0x1827, 0x1828,
  0x1829, 0x182a, 0x182b, 0x182c, 0x182d, 0x182e, 0x182f, 0x1830, 0x1831,
  0x1832, 0x1833, 0x1834, 0x1835, 0x1836, 0x1837, 0x1838, 0x1839, 0x183a,
  0x183b, 0x183c, 0x183d, 0x183e, 0x183f, 0x1840, 0x1841, 0x1842, 0x1843,
  0x1844, 0x1845, 0x1846, 0x1847, 0x1848, 0x1849, 0x184a, 0x184b, 0x184c,
  0x184d, 0x184e, 0x184f, 0x1850, 0x1851, 0x1852, 0x1853, 0x1854, 0x1855,
  0x1856, 0x1857, 0x1858, 0x1859, 0x185a, 0x185b, 0x185c, 0x185d, 0x185e,
  0x185f, 0x1860, 0x1861, 0x1862, 0x1863, 0x1864, 0x1865, 0x1866, 0x1867,
  0x1868, 0x1869, 0x186a, 0x186b, 0x186c, 0x186d, 0x186e, 0x186f, 0x1870,
  0x1871, 0x1872, 0x1873, 0x1874, 0x1875, 0x1876, 0x1877, 0x1878, 0x1887,
  0x1888, 0x1889, 0x188a, 0x188b, 0x188c, 0x188d, 0x188e, 0x188f, 0x1890,
  0x1891, 0x1892, 0x1893, 0x1894, 0x1895, 0x1896, 0x1897, 0x1898, 0x1899,
  0x189a, 0x189b, 0x189c, 0x189d, 0x189e, 0x189f, 0x18a0, 0x18a1, 0x18a2,
  0x18a3, 0x18a4, 0x18a5, 0x18a6, 0x18a7, 0x18a8, 0x18aa, 0xa840, 0xa841,
  0xa842, 0xa843, 0xa844, 0xa845, 0xa846, 0xa847, 0xa848, 0xa849, 0xa84a,
  0xa84b, 0xa84c, 0xa84d, 0xa84e, 0xa84f, 0xa850, 0xa851, 0xa852, 0xa853,
  0xa854, 0xa855, 0xa856, 0xa857, 0xa858, 0xa859, 0xa85a, 0xa85b, 0xa85c,
  0xa85d, 0xa85e, 0xa85f, 0xa860, 0xa861, 0xa862, 0xa863, 0xa864, 0xa865,
  0xa866, 0xa867, 0xa868, 0xa869, 0xa86a, 0xa86b, 0xa86c, 0xa86d, 0xa86e,
  0xa86f, 0xa870, 0xa871, 0x10ac0, 0x10ac1, 0x10ac2, 0x10ac3, 0x10ac4, 0x10ad3,
  0x10ad4, 0x10ad5, 0x10ad6, 0x10ad8, 0x10ad9, 0x10ada, 0x10adb, 0x10adc,
  0x10ade, 0x10adf, 0x10ae0, 0x10aeb, 0x10aec, 0x10aed, 0x10aee, 0x10b80,
  0x10b82, 0x10b86, 0x10b87, 0x10b88, 0x10b8a, 0x10b8b, 0x10b8d, 0x10b90,
  0x10bad, 0x10bae, 0x10d01, 0x10d02, 0x10d03, 0x10d04, 0x10d05, 0x10d06,
  0x10d07, 0x10d08, 0x10d09, 0x10d0a, 0x10d0b, 0x10d0c, 0x10d0d, 0x10d0e,
  0x10d0f, 0x10d10, 0x10d11, 0x10d12, 0x10d13, 0x10d14, 0x10d15, 0x10d16,
  0x10d17, 0x10d18, 0x10d19, 0x10d1a, 0x10d1b, 0x10d1c, 0x10d1d, 0x10d1e,
  0x10d1f, 0x10d20, 0x10d21, 0x10d23, 0x10ec3, 0x10ec4, 0x10f30, 0x10f31,
  0x10f32, 0x10f34, 0x10f35, 0x10f36, 0x10f37, 0x10f38, 0x10f39, 0x10f3a,
  0x10f3b, 0x10f3c, 0x10f3d, 0x10f3e, 0x10f3f, 0x10f40, 0x10f41, 0x10f42,
  0x10f43, 0x10f44, 0x10f51, 0x10f52, 0x10f53, 0x10f70, 0x10f71, 0x10f72,
  0x10f73, 0x10f76, 0x10f77, 0x10f78, 0x10f79, 0x10f7a, 0x10f7b, 0x10f7c,
  0x10f7d, 0x10f7e, 0x10f7f, 0x10f80, 0x10f81, 0x10fb0, 0x10fb2, 0x10fb3,
  0x10fb8, 0x10fbb, 0x10fbc, 0x10fbe, 0x10fbf, 0x10fc1, 0x10fc4, 0x10fca,
  0x1e900, 0x1e901, 0x1e902, 0x1e903, 0x1e904, 0x1e905, 0x1e906, 0x1e907,
  0x1e908, 0x1e909, 0x1e90a, 0x1e90b, 0x1e90c, 0x1e90d, 0x1e90e, 0x1e90f,
  0x1e910, 0x1e911, 0x1e912, 0x1e913, 0x1e914, 0x1e915, 0x1e916, 0x1e917,
  0x1e918, 0x1e919, 0x1e91a, 0x1e91b, 0x1e91c, 0x1e91d, 0x1e91e, 0x1e91f,
  0x1e920, 0x1e921, 0x1e922, 0x1e923, 0x1e924, 0x1e925, 0x1e926, 0x1e927,
  0x1e928, 0x1e929, 0x1e92a, 0x1e92b, 0x1e92c, 0x1e92d, 0x1e92e, 0x1e92f,
  0x1e930, 0x1e931, 0x1e932, 0x1e933, 0x1e934, 0x1e935, 0x1e936, 0x1e937,
  0x1e938, 0x1e939, 0x1e93a, 0x1e93b, 0x1e93c, 0x1e93d, 0x1e93e, 0x1e93f,
  0x1e940, 0x1e941, 0x1e942, 0x1e943,
]);

const JT_C = new Set([0x0640, 0x07fa, 0x0883, 0x0884, 0x0885, 0x180a, 0x200d]);

const JT_T = new Set([0x070f, 0x1885, 0x1886, 0x1e94b]);

// Utility: iterate Unicode code points in a JS string
function* codePoints(str) {
  let i = 0;
  while (i < str.length) {
    const cp = str.codePointAt(i);
    yield cp;
    i += cp > 0xffff ? 2 : 1;
  }
}

export function joiningType(cp) {
  if (JT_R.has(cp)) return "R";
  if (JT_L.has(cp)) return "L";
  if (JT_D.has(cp)) return "D";
  if (JT_C.has(cp)) return "C";
  if (JT_T.has(cp)) return "T";
  if (JT_U.has(cp)) return "U";
  // Default to Non_Joining if unknown
  return "U";
}

const ZWNJ = 0x200c; // Zero Width Non-Joiner
// Treat Join_Causing (ZWJ U+200D, Tatweel U+0640, etc.) via JT_C table

/** Determine whether `current` connects to `next` (Arabic cursive) */
export function connectsToNext(current, next) {
  if (!current || !next) return false;

  // First base cp from current
  let curCp = null;
  for (const cp of codePoints(current)) {
    if (joiningType(cp) !== "T") {
      curCp = cp;
      break;
    }
  }
  if (curCp == null) return false;

  // First non-transparent cp from next
  let nextCp = null;
  for (const cp of codePoints(next)) {
    if (joiningType(cp) !== "T") {
      nextCp = cp;
      break;
    }
  }
  if (nextCp == null) return false;

  if (curCp === ZWNJ || nextCp === ZWNJ) return false;

  const jtCur = joiningType(curCp);
  const jtNext = joiningType(nextCp);

  // Require neighbor capability; Join_Causing (C) is handled implicitly by shaping engine,
  // but it does not override capability checks.
  const canJoinRight = jtCur === "D" || jtCur === "L";
  const canJoinLeft = jtNext === "D" || jtNext === "R";

  return canJoinRight && canJoinLeft;
}

// Joiner code points
const TATWEEL_ = "\u0640"; // join-causing, renders a visible stretch if a join occurs
const ZWJ_ = "\u200D"; // join-causing (zero-width), encourages joining
const ZWNJ_ = "\u200C"; // non-joiner (zero-width), breaks joining

export const PositionalShape = {
  isolated: "isolated",
  initial: "initial",
  medial: "medial",
  final: "final",
};

export const TargetAffixes = {
  prefix: "",
  suffix: "",
  shape: PositionalShape.isolated,
};

/**
 * Given a triplet [L1, target, L3], compute the positional shape that the
 * target actually took, and return the prefix/suffix you should use to impose
 * that same shape on single response letters.
 *
 * Rules (from your spec):
 * - If L1 connects to target, we *induce a left join* using TATWEEL as prefix.
 * - If target connects to L3, we *induce a right join* using ZWJ as suffix.
 * - Otherwise, leave that side empty (no join).
 *
 * Notes:
 * - We intentionally do NOT add ZWNJ on non-joining sides; empty is enough
 *   in the response grid where each letter is isolated.
 * - TATWEEL (prefix) was chosen per your observation that ZWJ as prefix
 *   wasnâ€™t reliable across fonts; TATWEEL works robustly.
 */
export const computeTargetAffixes = (triplet) => {
  const [L1, T, L3] = triplet;

  const joinsLeft = connectsToNext(L1, T);
  const joinsRight = connectsToNext(T, L3);

  const prefix = joinsLeft ? TATWEEL_ : "";
  const suffix = joinsRight ? ZWJ_ : "";

  let shape =
    joinsLeft && joinsRight
      ? PositionalShape.medial
      : joinsLeft && !joinsRight
      ? PositionalShape.final
      : !joinsLeft && joinsRight
      ? PositionalShape.initial
      : PositionalShape.isolated;

  return { prefix, suffix, shape };
};

/**
 * Build the actual display glyph for a response-letter X, using the affixes
 * computed from the targetâ€™s triplet.
 *
 * Example:
 *   const aff = computeTargetAffixes([L1, T, L3]);
 *   const s = makeResponseGlyph("Ø¨", aff); // â†’ prefix + "Ø¨" + suffix
 */
export const makeResponseGlyph = (letter, affixes) => {
  return `${affixes.prefix}${letter}${affixes.suffix}`;
};
